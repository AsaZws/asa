(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{285:function(e,t,s){"use strict";s.r(t),t.default=[{title:"2019-11-22【MySQL数据库学习笔记】",path:"/posts/2019-11-22%E3%80%90MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91.html",strippedContent:" 非常不错的总结，强烈建议保存下来，需要的时候看一看。    \x3c!-- TOC --\x3e  - [基本操作](#基本操作)  - [数据库操作](#数据库操作)  - [表的操作](#表的操作)  - [数据操作](#数据操作)  - [字符集编码](#字符集编码)  - [数据类型(列类型)](#数据类型列类型)  - [列属性(列约束)](#列属性列约束)  - [建表规范](#建表规范)  - [SELECT](#select)  - [UNION](#union)  - [子查询](#子查询)  - [连接查询(join)](#连接查询join)  - [TRUNCATE](#truncate)  - [备份与还原](#备份与还原)  - [视图](#视图)  - [事务(transaction)](#事务transaction)  - [锁表](#锁表)  - [触发器](#触发器)  - [SQL编程](#sql编程)  - [存储过程](#存储过程)  - [用户和权限管理](#用户和权限管理)  - [表维护](#表维护)  - [杂项](#杂项)    \x3c!-- /TOC --\x3e    ### 基本操作    ```mysql  /* Windows服务 */  -- 启动MySQL      net start mysql  -- 创建Windows服务      sc create mysql binPath= mysqld_bin_path(注意：等号与值之间有空格)  /* 连接与断开服务器 */  mysql -h 地址 -P 端口 -u 用户名 -p 密码  SHOW PROCESSLIST -- 显示哪些线程正在运行  SHOW VARIABLES -- 显示系统变量信息  ```    ### 数据库操作    ```mysql  /* 数据库操作 */ ------------------  -- 查看当前数据库      SELECT DATABASE();  -- 显示当前时间、用户名、数据库版本      SELECT now(), user(), version();  -- 创建库      CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项      数据库选项：          CHARACTER SET charset_name          COLLATE collation_name  -- 查看已有库      SHOW DATABASES[ LIKE 'PATTERN']  -- 查看当前库信息      SHOW CREATE DATABASE 数据库名  -- 修改库的选项信息      ALTER DATABASE 库名 选项信息  -- 删除库      DROP DATABASE[ IF EXISTS] 数据库名          同时删除该数据库相关的目录及其目录内容  ```    ### 表的操作     ```mysql  -- 创建表      CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项]          每个字段必须有数据类型          最后一个字段后不能有逗号          TEMPORARY 临时表，会话结束时表自动消失          对于字段的定义：              字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT 'string']  -- 表选项      -- 字符集          CHARSET = charset_name          如果表没有设定，则使用数据库字符集      -- 存储引擎          ENGINE = engine_name          表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同          常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive          不同的引擎在保存表的结构和数据时采用不同的方式          MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引          InnoDB表文件含义：.frm表定义，表空间数据和日志文件          SHOW ENGINES -- 显示存储引擎的状态信息          SHOW ENGINE 引擎名 {LOGS|STATUS} -- 显示存储引擎的日志或状态信息      -- 自增起始数      \tAUTO_INCREMENT = 行数      -- 数据文件目录          DATA DIRECTORY = '目录'      -- 索引文件目录          INDEX DIRECTORY = '目录'      -- 表注释          COMMENT = 'string'      -- 分区选项          PARTITION BY ... (详细见手册)  -- 查看所有表      SHOW TABLES[ LIKE 'pattern']      SHOW TABLES FROM  库名  -- 查看表结构      SHOW CREATE TABLE 表名 （信息更详细）      DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE 'PATTERN']      SHOW TABLE STATUS [FROM db_name] [LIKE 'pattern']  -- 修改表      -- 修改表本身的选项          ALTER TABLE 表名 表的选项          eg: ALTER TABLE 表名 ENGINE=MYISAM;      -- 对表进行重命名          RENAME TABLE 原表名 TO 新表名          RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库）          -- RENAME可以交换两个表名      -- 修改表的字段机构（13.1.2. ALTER TABLE语法）          ALTER TABLE 表名 操作名          -- 操作名              ADD[ COLUMN] 字段定义       -- 增加字段                  AFTER 字段名          -- 表示增加在该字段名后面                  FIRST               -- 表示增加在第一个              ADD PRIMARY KEY(字段名)   -- 创建主键              ADD UNIQUE [索引名] (字段名)-- 创建唯一索引              ADD INDEX [索引名] (字段名) -- 创建普通索引              DROP[ COLUMN] 字段名      -- 删除字段              MODIFY[ COLUMN] 字段名 字段属性     -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)              CHANGE[ COLUMN] 原字段名 新字段名 字段属性      -- 支持对字段名修改              DROP PRIMARY KEY    -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)              DROP INDEX 索引名 -- 删除索引              DROP FOREIGN KEY 外键    -- 删除外键  -- 删除表      DROP TABLE[ IF EXISTS] 表名 ...  -- 清空表数据      TRUNCATE [TABLE] 表名  -- 复制表结构      CREATE TABLE 表名 LIKE 要复制的表名  -- 复制表结构和数据      CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名  -- 检查表是否有错误      CHECK TABLE tbl_name [, tbl_name] ... [option] ...  -- 优化表      OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...  -- 修复表      REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]  -- 分析表      ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...  ```    ### 数据操作    ```mysql  /* 数据操作 */ ------------------  -- 增      INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...]          -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。          -- 可同时插入多条数据记录！          REPLACE 与 INSERT 完全一样，可互换。      INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...]  -- 查      SELECT 字段列表 FROM 表名[ 其他子句]          -- 可来自多个表的多个字段          -- 其他子句可以不使用          -- 字段列表可以用*代替，表示所有字段  -- 删      DELETE FROM 表名[ 删除条件子句]          没有条件子句，则会删除全部  -- 改      UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件]  ```    ### 字符集编码    ```mysql  /* 字符集编码 */ ------------------  -- MySQL、数据库、表、字段均可设置编码  -- 数据编码与客户端编码不需一致  SHOW VARIABLES LIKE 'character_set_%'   -- 查看所有字符集编码项      character_set_client        客户端向服务器发送数据时使用的编码      character_set_results       服务器端将结果返回给客户端所使用的编码      character_set_connection    连接层编码  SET 变量名 = 变量值      SET character_set_client = gbk;      SET character_set_results = gbk;      SET character_set_connection = gbk;  SET NAMES GBK;  -- 相当于完成以上三个设置  -- 校对集      校对集用以排序      SHOW CHARACTER SET [LIKE 'pattern']/SHOW CHARSET [LIKE 'pattern']   查看所有字符集      SHOW COLLATION [LIKE 'pattern']     查看所有校对集      CHARSET 字符集编码     设置字符集编码      COLLATE 校对集编码     设置校对集编码  ```    ### 数据类型(列类型)    ```mysql  /* 数据类型（列类型） */ ------------------  1. 数值类型  -- a. 整型 ----------      类型         字节     范围（有符号位）      tinyint     1字节    -128 ~ 127      无符号位：0 ~ 255      smallint    2字节    -32768 ~ 32767      mediumint   3字节    -8388608 ~ 8388607      int         4字节      bigint      8字节      int(M)  M表示总位数      - 默认存在符号位，unsigned 属性修改      - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改          例：int(5)   插入一个数'123'，补填后为'00123'      - 在满足要求的情况下，越小越好。      - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。  -- b. 浮点型 ----------      类型             字节     范围      float(单精度)     4字节      double(双精度)    8字节      浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。          不同于整型，前后均会补填0.      定义浮点型时，需指定总位数和小数位数。          float(M, D)     double(M, D)          M表示总位数，D表示小数位数。          M和D的大小会决定浮点数的范围。不同于整型的固定范围。          M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。          支持科学计数法表示。          浮点数表示近似值。  -- c. 定点数 ----------      decimal -- 可变长度      decimal(M, D)   M也表示总位数，D表示小数位数。      保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。      将浮点数转换为字符串来保存，每9位数字保存为4个字节。  2. 字符串类型  -- a. char, varchar ----------      char    定长字符串，速度快，但浪费空间      varchar 变长字符串，速度慢，但节省空间      M表示能存储的最大长度，此长度是字符数，非字节数。      不同的编码，所占用的空间不同。      char,最多255个字符，与编码无关。      varchar,最多65535字符，与编码有关。      一条有效记录最大不能超过65535个字节。          utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符      varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。      varchar 的最大有效长度由最大行大小和使用的字符集确定。      最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。      例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3  -- b. blob, text ----------      blob 二进制字符串（字节字符串）          tinyblob, blob, mediumblob, longblob      text 非二进制字符串（字符字符串）          tinytext, text, mediumtext, longtext      text 在定义时，不需要定义长度，也不会计算总长度。      text 类型在定义时，不可给default值  -- c. binary, varbinary ----------      类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。      char, varchar, text 对应 binary, varbinary, blob.  3. 日期时间类型      一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。      datetime    8字节    日期及时间     1000-01-01 00:00:00 到 9999-12-31 23:59:59      date        3字节    日期         1000-01-01 到 9999-12-31      timestamp   4字节    时间戳        19700101000000 到 2038-01-19 03:14:07      time        3字节    时间         -838:59:59 到 838:59:59      year        1字节    年份         1901 - 2155  datetime    YYYY-MM-DD hh:mm:ss  timestamp   YY-MM-DD hh:mm:ss              YYYYMMDDhhmmss              YYMMDDhhmmss              YYYYMMDDhhmmss              YYMMDDhhmmss  date        YYYY-MM-DD              YY-MM-DD              YYYYMMDD              YYMMDD              YYYYMMDD              YYMMDD  time        hh:mm:ss              hhmmss              hhmmss  year        YYYY              YY              YYYY              YY  4. 枚举和集合  -- 枚举(enum) ----------  enum(val1, val2, val3...)      在已知的值中进行单选。最大数量为65535.      枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。      表现为字符串类型，存储却是整型。      NULL值的索引是NULL。      空字符串错误值的索引值是0。  -- 集合（set） ----------  set(val1, val2, val3...)      create table tab ( gender set('男', '女', '无') );      insert into tab values ('男, 女');      最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。      当创建表时，SET成员值的尾部空格将自动被删除。  ```    ### 列属性(列约束)    ```mysql  /* 列属性（列约束） */ ------------------  1. PRIMARY 主键      - 能唯一标识记录的字段，可以作为主键。      - 一个表只能有一个主键。      - 主键具有唯一性。      - 声明字段时，用 primary key 标识。          也可以在字段列表之后声明              例：create table tab ( id int, stu varchar(10), primary key (id));      - 主键字段的值不能为null。      - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。          例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));  2. UNIQUE 唯一索引（唯一约束）      使得某字段的值也不能重复。  3. NULL 约束      null不是数据类型，是列的一个属性。      表示当前列是否可以为null，表示什么都没有。      null, 允许为空。默认。      not null, 不允许为空。      insert into tab values (null, 'val');          -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null  4. DEFAULT 默认值属性      当前字段的默认值。      insert into tab values (default, 'val');    -- 此时表示强制使用默认值。      create table tab ( add_time timestamp default current_timestamp );          -- 表示将当前时间的时间戳设为默认值。          current_date, current_time  5. AUTO_INCREMENT 自动增长约束      自动增长必须为索引（主键或unique）      只能存在一个字段为自动增长。      默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;  6. COMMENT 注释      例：create table tab ( id int ) comment '注释内容';  7. FOREIGN KEY 外键约束      用于限制主表与从表数据完整性。      alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id);          -- 将表t1的t1_id外键关联到表t2的id字段。          -- 每个外键都有一个名字，可以通过 constraint 指定      存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。      作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。      MySQL中，可以对InnoDB引擎使用外键约束：      语法：      foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]      此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。      可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。      如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择：      1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。      2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。      3. restrict，拒绝父表删除和更新。      注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。    ```    ### 建表规范    ```mysql  /* 建表规范 */ ------------------      -- Normal Format, NF          - 每个表保存一个实体信息          - 每个具有一个ID字段作为主键          - ID主键 + 原子表      -- 1NF, 第一范式          字段不能再分，就满足第一范式。      -- 2NF, 第二范式          满足第一范式的前提下，不能出现部分依赖。          消除复合主键就可以避免部分依赖。增加单列关键字。      -- 3NF, 第三范式          满足第二范式的前提下，不能出现传递依赖。          某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。          将一个实体信息的数据放在一个表内实现。  ```    ### SELECT     ```mysql  /* SELECT */ ------------------  SELECT [ALL|DISTINCT] select_expr FROM -> WHERE -> GROUP BY [合计函数] -> HAVING -> ORDER BY -> LIMIT  a. select_expr      -- 可以用 * 表示所有字段。          select * from tb;      -- 可以使用表达式（计算公式、函数调用、字段也是个表达式）          select stu, 29+25, now() from tb;      -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。          - 使用 as 关键字，也可省略 as.          select stu+10 as add10 from tb;  b. FROM 子句      用于标识查询来源。      -- 可以为表起别名。使用as关键字。          SELECT * FROM tb1 AS tt, tb2 AS bb;      -- from子句后，可以同时出现多个表。          -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。          SELECT * FROM tb1, tb2;      -- 向优化符提示如何选择索引          USE INDEX、IGNORE INDEX、FORCE INDEX          SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3;          SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3;  c. WHERE 子句      -- 从from获得的数据源中进行筛选。      -- 整型1表示真，0表示假。      -- 表达式由运算符和运算数组成。          -- 运算数：变量（字段）、值、函数返回值          -- 运算符：              =, <=>, <>, !=, <=, <, >=, >, !, &&, ||,              in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor              is/is not 加上ture/false/unknown，检验某个值的真假              <=>与<>功能相同，<=>可用于null比较  d. GROUP BY 子句, 分组子句      GROUP BY 字段/别名 [排序方式]      分组后会进行排序。升序：ASC，降序：DESC      以下[合计函数]需配合 GROUP BY 使用：      count 返回不同的非NULL值数目  count(*)、count(字段)      sum 求和      max 求最大值      min 求最小值      avg 求平均值      group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。  e. HAVING 子句，条件子句      与 where 功能、用法相同，执行时机不同。      where 在开始时执行检测数据，对原数据进行过滤。      having 对筛选出的结果再  ```    > 原文地址：https://shockerli.net/post/1000-line-mysql-note/ ，JavaGuide 对本文进行了简答排版，新增了目录。  > 作者：格物  "},{title:"2019-09-30【车牌键盘】",path:"/posts/2019-09-30%E3%80%90%E8%BD%A6%E7%89%8C%E9%94%AE%E7%9B%98%E3%80%91.html",strippedContent:' [最新最完美车牌框输入键盘](https://asazws.github.io/binding/parkingPayment/parkingPayment.html)    [车牌最新输入框版](https://asazws.github.io/binding/plate-object/plate.html)    [车牌键盘框](https://asazws.github.io/binding/binding.html)    ## 车牌键盘  我们做智慧停车的，在H5开发一个车牌输入的键盘，下面是效果图，      有多种展示方式，每种的代码结构不一样，需要哪种就用哪种，单独分开的，代码有累赘的地方希望指出来。      如果想用Vue版本的，请点击这里 => [Vue版](https://github.com/AsaZws/Keyboard)    ### 这种使用起来非常简单，原生的js，是列表框的形式，css用flex布局，适应各种屏幕，具体请看下方  plateNumbers => 里面可以自定义车牌初始化，例如渝A     base.css => 是初始化html默认样式的，可以加入你自己项目默认的，需要引入index.css     queryDetail => 查询方法也可以替换     plate1.show() => 显示键盘方法     plate1.hide() => 隐藏键盘方法     plate.plateNumber => 输入的车牌号码    <img :src=\'$withBase("/images/keyboard.gif")\' alt=\'键盘效果图\'>    - https://github.com/AsaZws/binding/tree/master/parkingPayment    ```html  \x3c!-- base清除默认样式，也可以加你自己的 --\x3e  <link rel="stylesheet" href="css/base.css">  \x3c!-- 里面上半部分是键盘的css，下半部分是车牌框的css --\x3e  <link rel="stylesheet" href="css/index.css">  \x3c!-- 头部背景 --\x3e  <div class="header"></div>     \x3c!-- 车牌内容 --\x3e    <div class="keyboard-padding" id="plate" plateNumbers="粤B">      <p>请输入车牌</p>      <div class="plate">        \x3c!-- 车牌框 --\x3e        <div class="plate-frame"></div>        \x3c!-- 查询按钮 --\x3e        <div class="plate-button">          <a href="javascript:queryDetail();" class="queryDetail noquery">查询</a>        </div>      </div>      \x3c!-- 车牌键盘 --\x3e      <div class="keyboard">        <div class="shut-down"><p>确定</p></div>        <div class="place-letter"></div>      </div>    </div>  ```  ```js  var plate1 = new Plate("plate");  // 查询车牌的方法  function queryDetail() {      if(plate1.plateNumber.length < 7) {          console.log("请输入正确车牌");      } else {          // 获取车牌          console.log(plate1.plateNumber);          // 隐藏键盘          plate1.hide();      }  }  ```    ### 这种使用起来比较简单，是js原生的，个人感觉使用起来比较快，具体请看下方。  <img :src=\'$withBase("/images/car.gif")\' alt=\'键盘效果图\'>    - https://github.com/AsaZws/binding/tree/master/plate-object    ```html  <link rel="stylesheet" href="css/plate.css">  <div class="weui-cell__bd" id="plate">      <input class="weui-input plate" readonly type="text" placeholder="请输入车牌" maxlength="8" value="粤B">  </div>  ```  ```js  var plate1 = new Plate("plate");  ```    ### 这种需要把html结构写出来，没有在js中进行循环出来,这个有引入jquery,具体请看下方js代码链接。  <img :src=\'$withBase("/images/binding.gif")\' alt=\'键盘效果图\'>    - https://github.com/AsaZws/binding/blob/master/js/binding.js    ```html  <link rel="stylesheet" href="css/binding.css"/>  \x3c!-- 车牌 --\x3e  <div class="plate">      <ul id="plate">      <li>粤</li>      <li>B</li>      <li class="active"></li>      <li></li>      <li></li>      <li></li>      <li></li>      <li>          <div class="new"><span>+</span> <i>新能源</i></div>      </li>      </ul>  </div>  \x3c!-- 虚拟键盘 --\x3e  <div class="keyboard-footer">      \x3c!-- 键盘 --\x3e      <div class="keyboard" id="shutkey">          <div class="shut" id="shut">关闭</div>          <ul id="keyboard">              <div class="area-one">              <li>1</li>              <li>2</li>              <li>3</li>              <li>4</li>              <li>5</li>              <li>6</li>              <li>7</li>              <li>8</li>              <li>9</li>              <li>0</li>              </div>              <div class="area-one">              <li>Q</li>              <li>W</li>              <li>E</li>              <li>R</li>              <li>T</li>              <li>Y</li>              <li>U</li>              <li>P</li>              <li>港</li>              <li>澳</li>              </div>              <div class="area-one">              <li>A</li>              <li>S</li>              <li>D</li>              <li>F</li>              <li>G</li>              <li>H</li>              <li>J</li>              <li>K</li>              <li>L</li>              <li>学</li>              </div>              <div class="area-one">              <li>Z</li>              <li>X</li>              <li>C</li>              <li>V</li>              <li>B</li>              <li>N</li>              <li>M</li>              <li>警</li>              <li class="delet">删除</li>              </div>          </ul>      </div>      \x3c!-- 地区车牌简称 --\x3e      <div class="area" id="area">          <div class="shut" id="shuta">关闭</div>          <ul id="keyboarda">          <div class="area-one">              <li>京</li>              <li>津</li>              <li>沪</li>              <li>渝</li>              <li>蒙</li>              <li>新</li>              <li>藏</li>              <li>宁</li>              <li>桂</li>              <li>黑</li>          </div>          <div class="area-one">              <li>吉</li>              <li>辽</li>              <li>晋</li>              <li>冀</li>              <li>青</li>              <li>鲁</li>              <li>豫</li>              <li>苏</li>              <li>皖</li>          </div>          <div class="area-one">              <li>浙</li>              <li>闽</li>              <li>赣</li>              <li>湘</li>              <li>鄂</li>              <li>粤</li>              <li>琼</li>              <li>甘</li>          </div>          <div class="area-one">              <li>陕</li>              <li>贵</li>              <li>云</li>              <li>川</li>              \x3c!-- <li>删除</li> --\x3e          </div>          </ul>      </div>  </div>  <script src="js/jquery.min.js"><\/script>  <script src="js/binding.js"><\/script>  ```       以上    原文请点击 => [github](https://github.com/AsaZws/binding)'},{title:"2019-05-26【寄生组合式继承】",path:"/posts/2019-05-26%E3%80%90%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF%E3%80%91.html",strippedContent:' ### 组合继承模式的问题      最大的问题是无论什么情况下都会调用两次超类型构造函数：一次式创建子类型原型的时候，另一次是在子类型构造函数内部，但我们不得不在调用子类型构造函数时重写这些属性    #### 下面我们来看一个实例    ```js  function SuperType(name) {      this.name = name;      this.colors = ["red", "blue", "green"];  }  SuperType.prototype.sayName = function() {      console.log(this.name);  }  function SubType(name, age) {      SuperType.call(this, name);       // 第一次调用SuperType()      this.age = age;  }  SubType.prototype = new SuperType();  // 第一次调用SuperType()  SubType.prototype.constructor = SubType;  SubType.prototype.sayAge = function() {      console.log(this.age)  }  ```    在第一次调用SuperType构造函数时，SubType.prototype会得到两个属性：name和colors；它们都是SuperType的实例属性，只不过现在位于SubType的原型中。当调用SubType构造函数时，又会调用一次SuperType构造函数，这一次又在新对象上创建了这个实例属性name和colors。于是这两个属性就屏蔽了原型中的同名属性。    下面我们来解决这个问题，采用寄生组合式继承，即借用构造函数来继承属性，通过原型链的混成形式来继承方法。其后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承类型的原型，然后再将结果指定给子类型的原型。    寄生组合式继承的基本模式如下所示    ```js  function inheritPrototype(subType, superType) {      var prototype = object(superType.prototype);  // 创建对象      prototype.constructor = subType;              // 增强对象      subType.prototype = prototype;                // 指定对象  }  ```    这个示例中的inheritPrototype()函数实现来寄生组合式继承的最简单形式。这个函数接收两个参数：子类型构造函数和超类型构造函数。在函数内部，第一步是创建超类型的一个副本。第二步是为创建的副本添加constructor属性，从而弥补因重写原型而失去的默认的constructor属性。最后一步，将创建的对象（即副本）赋值给子类型的原型。这样，我们就可以调用inherit-Prototype()函数的语句，去替换前面例子中为子类型原型赋值的语句了。    下面再看一个例子  ```js  function SuperType(name) {      this.name = name;      this.colors = ["red", "blue", "green"];  }  SuperType.prototype.sayName = function() {      console.log(this.name);  }  function SubType(name, age) {      SuperType.call(this, name);      this.age = age;  }  inheritPrototype(SubType, SuperType)  SubType.prototype.sayAge = function() {      console.log(this.age);  }  ```    这个例子的高效率体现在它只调用了一次SuperType构造函数，并且因此避免了在SubType.prototype上面创建不必要的/多余的属性，与此同时，原型链还能保持不变，因此，还能够正常使用instanceof和isPrototypeOf()，在ES5普遍认为寄生组合式继承是引用类型最理想的继承范式。    以上    参考js高级程序设计第三版6.3.6——继承'},{title:"2019-05-24【原型链继承】",path:"/posts/2019-05-24%E3%80%90%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF%E3%80%91.html",strippedContent:' ### 原型链的问题      原型链虽然很强大，可以用它来实现继承，但是它也存在一些问题。其中，最主要的问题是来自包含引用类型值的原型，它会影响原来的值。    下面我们来看一个实例    #### js    下面的代码会说明这个问题    ```js  function SuperType() {      this.colors = ["red","blue","green"];  }  function SubType() {}    //继承来SuperType  SubType.prototype = new SuperType();    var instance1 = new SubType();  instance1.colors.push("black");  console.log(instance1.colors);  // ["red", "blue", "green", "black"]    var instance2 = new SubType();  console.log(instance2.colors);  // ["red", "blue", "green", "black"]  ```    上面这个例子我们可以看到当SubType通过原型链继承链SuperType之后，SubType.prototype就变成了SuperType的一个实例，结果SubType的所有实例都会共享这一个colors属性。      借用构造函数，通过apply()和call()方法可以在（将来）新创建的对象上执行构造函数，实现继承且拷贝副本，不影响原有属性。  以下     ```js  function SuperType() {      this.colors = ["red","blue","green"];  }  function SubType() {      // 继承了SuperType      SuperType.call(this);  }  var instance1 = new SubType();  instance1.colors.push("black");  console.log(instance1.colors)   // ["red", "blue", "green", "black"]  var instance2 = new SubType();  console.log(instance2.colors);  // ["red", "blue", "green"]  ```    以上    参考js高级程序设计第三版6.3——继承'},{title:"2019-05-18【前端分页】",path:"/posts/2019-05-18%E3%80%90%E5%89%8D%E7%AB%AF%E5%88%86%E9%A1%B5%E3%80%91.html",strippedContent:' ### 前端分页做来玩玩      分页常见于数据量大的时候，但是一般都是后端来实现的，前端请求就完事了，现在就前端也想来研究一下，大约实现了下功能，还有待优化。      #### html    结构包含首页尾页，上一页下一页，自定义输入页码。    ```html  <div class="main">      <ul>          <li class="first" id="home">首页</li>          <li class="first" id="before">上一页</li>          <li id="number"></li>          <li class="first" id="next">下一页</li>          <li class="first" id="last">尾页</li>          <li class="current"></li>          <li class="jump">              <input type="text" id="inp">              <div class="l_jump">确定</div>          </li>      </ul>  </div>  ```    ```css  * {      padding: 0;      margin: 0;  }  ul, li {      list-style: none;  }  input {      outline: none;      box-sizing: border-box;  }  .first {      color: #666;      display: inline-block;      vertical-align: top;      border: 1px solid #ccc;      padding: 5px 9px;      font-size: 12px;      cursor: pointer;  }  #number {      display: inline-block;      vertical-align: top;  }  .num {      color: #666;      display: inline-block;      vertical-align: top;      border: 1px solid #ccc;      background-color: #fff;      padding: 5px 9px;      font-size: 12px;      margin-right: 6px;      cursor: pointer;  }  .current {      color: #3e89fa;      font-size: 12px;      display: inline-block;      vertical-align: top;      margin-left: 2px;      padding: 5px 9px;  }  #inp {      height: 29px;      width: 50px;      border: 1px solid #ccc;      padding: 0 4px;  }  .jump {      display: inline-block;      vertical-align: top;      font-size: 12px;  }  .l_jump {      display: inline-block;      vertical-align: top;      border: 1px solid #ccc;      padding: 5px 9px;      cursor: pointer;      color: #666;  }  ```    ```js  var sign = 1;    // 记录当前第几个块，如果最多为10个块，那么就是1-10  var b_sign = 1;  // 记录sign变动之前的sign的数值  var count = 20;  // 记录总共页数  var real_count=count<=10?count:10; // 定义最多有多少块  var real_change=0;  var o = 0;    if (real_count%2==0){      real_change=real_count/2;  } else {      real_change=real_count/2+0.5;      var o=1;  }    // 初始化模块  let i = 1;  while(i<=real_count) {      var val="<div class=\'num\' id="+i+">" +i+"</div>";      $("#number").append(val);      i++;  }    // 查找id=\'number\'块的所有子节点  function query_all(){      nodes = $("#number").find("div");      length=nodes.length;  };  query_all();    // 获取当前page  function currentPage() {      let use="#"+sign;      $(".current").text("当前"+$(use).text()+"/"+count+"页");  };  currentPage();    //将当前第sign块样式还原  var b_change=function(){      b_sign=sign;      let use="#"+b_sign;      $(use).css({"border":"1px solid #cccccc","backgroundColor":"#fff","color":"#666"})  }    // 将当前sign块样式改变，好区别于其他块  var blue_change=function(c){      let use="#"+c;      $(use).css({"border":"#3e89fa","backgroundColor":"#3e89fa","color":"#ffffff"});  }  // 页面第一次加载的时候，改变指定块样式  blue_change(sign);    // 当前sign块先还原样式，再改变sign，再改变改变后的sign块样式  function go_back(now_sign,kit) {      b_change();      if(kit==0) {          sign=now_sign;      } else if(kit==1) {          if(sign!=real_count)          sign++;      } else if(kit==2) {          if(sign!=1)          sign--;      }      blue_change(sign);  }    // 遍历改变id="number"的子节点内容  function change_add(c_add,kit) {      var p=c_add;      for(let j=0;j<length;j++) {          if(kit==0) {              nodes[j].innerHTML=p;              p++;          } else if(kit==1){              nodes[j].innerHTML=p;              p--;          } else if(kit==2){              nodes[j].innerHTML=parseInt(nodes[j].innerHTML)+1;          } else if(kit==3) {              nodes[j].innerHTML=parseInt(nodes[j].innerHTML)-1;          }      }  }    function for_num(use,id) {      let error_1="#"+real_change;      // 页面在最前或者最后      if($(error_1).text()==real_change||$(error_1).text()==count-real_change+1) {          // 判断点击的第一个一半的前面还是点击的第二个一半的后面          if($(use).text()<=real_change||$(use).text()>count-real_change) {              go_back(id,0);          } else {              go_back(real_change,0);              change_add($(use).text()-(real_change-1),0);          }          currentPage();      } else {          var inner=(o==0)?$(use).text()>=count-real_change:$(use).text()>count-real_change;          if($(use).text()<=real_change||inner) {              if($(use).text()<=real_change) {                  go_back($(use).text(),0);                  change_add(1,0);              } else {                  go_back(real_count-(count-$(use).text()),0);                  change_add(count-real_count+1,0);              }          } else {              go_back(real_change,0);              change_add($(use).text()-(real_change-1),0);          }      }      currentPage();  }    // 遍历每个div块，并为他们增加点击事件  for(let j=0;j<length;j++)  \t\t{  \t\t\tlet id=nodes[j].getAttribute("id");  \t\t\tlet use="#"+id;  \t\t\t$(use).bind("click",function(){  \t\t\t\tfor_num(use,id);  \t\t\t});  \t\t}    $("#home").bind("click",function() {      go_back(1,0);      change_add(1,0);      currentPage();  });  $("#before").bind("click",function() {      let use="#"+sign;      var inner=(o==0)?$(use).text()>=count-real_change:$(use).text()>count-real_change+1;      if($(use).text()<=real_change||inner) {          go_back(0,2);          currentPage();      }  })  $("#next").bind("click",function(){      let use="#"+sign;      if($(use).text()!=count) {          var inner = (o==0)?$(use).text()>=count-real_change:$(use).text()>count-real_change;          if($(use).text()<real_change||inner) {              go_back(0,1);              currentPage();          } else {              change_add(0,2);              currentPage();          }      }  })  $(".l_jump").bind("click",function(){      let val=$("#inp").val();  // 获取输入框的值      val=parseInt(val);      if(val>=1&&val<=count) {          var inner=(o==0)?val>=count-real_change:val>count-real_change;          // 如果是最前面的一半以前，或者是最后面的一半以后          if(val<=real_change||inner) {              if(val<=real_change) {                  go_back(val,0);                  change_add(1,0);              } else {                  go_back(real_count-(count-val),0);                  change_add(count-real_count+1,0);              }          } else {              go_back(real_change,0);              change_add(val-(real_change-1),0);          }      } else {          alert("没有这么多页")      }      currentPage()  })  ```    例子展示    <img :src=\'$withBase("/images/20190518fy.png")\' alt=\'分页\'>    以上    浏览链接： <https://asazws.github.io/Duck-leg/demo/pageTurning/index.html>'},{title:"2019-03-20【面向对象选项卡】",path:"/posts/2019-03-20%E3%80%90%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%80%89%E9%A1%B9%E5%8D%A1%E3%80%91.html",strippedContent:' ### 面向对象的选项卡      一般写一个选项卡的时候，用面向过程去写是比较简单的，但是想复用的时候，就比较麻烦了，但是用面向对象的方法去写一个选项卡，写的时候虽然复杂了点，但是想复用的时候就比较简单了，只需要new一下就可以了，下面我用面向过程和面向对象的两种方法，分别来写一下选项卡的例子      #### 面向过程的选项卡    我们来看一个例子,这样的结构很清晰，一目了然，但是不好复用。    ```html  <div class="tab" id="box1">      <input type="button" value="html" class="active">      <input type="button" value="css">      <input type="button" value="js">      <div style="display:block;">html</div>      <div>css</div>      <div>js</div>  </div>  ```    ```css  .tab input {      background: #f2f2f2;      border: 1px solid #ccc;  }  .tab .active {      background: #ccc;  }  .tab div {      width: 300px;      height: 250px;      display: none;      padding: 10px;      background: #f2f2f2;      border: 1px solid #ccc;  }  ```    ```js  window.onload = function () {      var oBox = document.getElementById(\'box1\');      var oBtn = oBox.getElementsByTagName(\'input\');      var oDiv = oBox.getElementsByTagName(\'div\');      for(var i=0; i<oBtn.length; i++) {          oBtn[i].index = i;          oBtn[i].onclick = function () {              for(var j=0; j<oBtn.length; j++) {                  oBtn[j].className=\'\';                  oDiv[j].style.display=\'none\';              }              this.className=\'active\';              oDiv[this.index].style.display=\'block\';          }      }  }  ```    例子展示    <img :src=\'$withBase("/images/20190304timeline.png")\' alt=\'面向对象选项卡\'>    #### 面向对象的选项卡    这个例子虽然看起来逻辑复杂点，但是仔细去理解this，还是挺简单的。    ```js  function Tab(id) {      var oBox = document.getElementById(id);      this.oBtn = oBox.getElementsByTagName(\'input\');      this.oDiv = oBox.getElementsByTagName(\'div\');        for(var i=0; i<this.oBtn.length; i++) {          this.oBtn[i].index = i;  // 获取索引          var _this = this;        // 保存this          this.oBtn[i].onclick = function() {              _this.clickBtn(this);              console.log(this);   // 点击哪个，指向哪个              console.log(_this);  // Tab对象          }      }  }  Tab.prototype.clickBtn = function(btn) {  // 为Tab原型添加点击选项卡方法      for(var j=0;j<this.oBtn.length; j++) {          this.oBtn[j].className = \'\';          this.oDiv[j].style.display = \'none\';      }      btn.className = \'active\';      this.oDiv[btn.index].style.display = \'block\';  }  ```    如果我们想复用，只需要加一个html，js中new一下就可以了      ```html  <div class="tab" id="box1">      <input type="button" value="html" class="active">      <input type="button" value="css">      <input type="button" value="js">      <div style="display:block;">html</div>      <div>css</div>      <div>js</div>  </div>  <div class="tab" id="box2">      <input type="button" value="html" class="active">      <input type="button" value="css">      <input type="button" value="js">      <div style="display:block;">html</div>      <div>css</div>      <div>js</div>  </div>  ```    ```js  window.onload = function() {      var box1 = new Tab("box1");      var box2 = new Tab("box2");  }  ```    以上    参考链接： <http://www.cnblogs.com/chiangchou/p/js-oop2.html>'},{title:"2019-03-14【原型对象是被很多实例共享的】",path:"/posts/2019-03-14%E3%80%90%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7%E6%98%AF%E8%A2%AB%E5%BE%88%E5%A4%9A%E5%AE%9E%E4%BE%8B%E5%85%B1%E4%BA%AB%E7%9A%84%E3%80%91.html",strippedContent:' ### 原型对象的问题      原型模式也不是没有缺点。首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。原型模式的最大问题是由其共享的本质所导致的。      原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性到也说的过去，通过在实例上添加了一个同名属性，可以隐藏原型中的对应属性。然而，对于包含引用类型的属性来说，问题就比较突出了。    我们来看一个例子。    ```js  function Person(){    }  Person.prototype = {      constructor: Person,      name: \'Nicholas\',      age: 29,      job: \'Software Engineer\',      friends: ["Shelby", "Court"],      sayName: function(){          console.log(this.name);      }  };  var person1 = new Person();  var person2 = new Person();  person1.friends.push("Van");  console.log(person1.friends);  // "Shelby,Court,Van"  console.log(person2.friends);  // "Shelby,Court,Van"  console.log(person1.friends === person2.friends); // true  console.log(person1.name === person2.name); // true  ```    friends数组存在与Person.prototype而非person1中，所以上面person2.friends(与person1.friends指向同一个数组)反应出来，而这个问题正是我们很少看到有人单独使用原型模式的原因所在。    以上'},{title:"2019-03-08【安卓手机键盘弹起顶起footer】",path:"/posts/2019-03-08%E3%80%90%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA%E9%94%AE%E7%9B%98%E5%BC%B9%E8%B5%B7%E9%A1%B6%E8%B5%B7footer%E3%80%91.html",strippedContent:' ### 安卓手机键盘弹起顶起footer      前天没发文章，确实是工作原因，这里提醒下自己，希望自己坚持，下面这个是这两天工作上遇到的问题，所以记录下来，下次就能避开这个坑。      昨晚领导截图发给我这个问题，于是我四处找解决办法，最终发现以监听键盘弹起或者落下来处理这个问题最佳！    ```js  var winHeight = $(window).height();   //获取当前页面高度  $(window).resize(function(){  var thisHeight=$(this).height();      if(winHeight - thisHeight >50){          $("#login-footer").hide();  //当软键盘弹出，隐藏底部      }else{          $("#login-footer").show();  //当软键盘收起，显示底部      }  });  ```    以上'},{title:"2019-03-05【VUE生命周期图】",path:"/posts/2019-03-05%E3%80%90VUE%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E3%80%91.html",strippedContent:" ### vue生命周期图详解      本篇我们学习 Vue 的生命周期，先来看一下 Vue 的生命周期的定义。      > 每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。     这是 Vue 官网上提供的描述信息，简单来说就是：在 Vue 从创建实例到最终完全消亡的过程中，会执行一系列的方法，用于对应当前 Vue 的状态，这些方法我们叫它：生命周期钩子，看一下下面的生命周期图示：    vue生命周期    <img :src='$withBase(\"/images/20190305the-life-cycle.png\")' alt='生命周期图详解'>  此图是我从GitChat上学习刘国栋的vue中得来      以上"},{title:"2019-03-04【纯css撸一个时间轴】",path:"/posts/2019-03-04%E3%80%90%E7%BA%AFCSS%E6%92%B8%E4%B8%80%E4%B8%AA%E6%97%B6%E9%97%B4%E8%BD%B4%E3%80%91.html",strippedContent:' ### 纯css撸一个时间轴    工作中有时会接到时间轴文字排版的需求，于是我就写了一个保存下来，以便以后用到      html代码    ```html  <div class="track-rcol">      <div class="track-list">          <ul>              <li class="first">                  <i class="node-icon">01</i>                  <span class="txt">客户通过手机端“发起申请”,自动派单。</span>              </li>              <li>                  <i class="node-icon">02</i>                  <span class="txt">我们承诺1个工作日内与您联系，确认您的需求并拟稿合同。</span>              </li>              <li>                  <i class="node-icon">03</i>                  <span class="txt">依照合同，按市场最短周期迅速办理。</span>              </li>              <li>                  <i class="node-icon">04</i>                  <span class="txt">我们工作人员回访客户，详细记录客户对我们服务情况的建议！</span>              </li>          </ul>      </div>  </div>  ```    一个外框"track-rcol"包裹，再一个外框"track-list"设置内外边距，"li"定义文字内边距、行高、左边框虚线，第一个"li>first"上边距为0，"node-icon"序号图标样式，"txt"设置一下字体大小或者样式就OK啦。    css代码  ```css  .track-rcol {    width: 100%;    color: #fff;  }  .track-list {    margin: 20px;    padding-left: 6px;    padding-bottom: 80px;    position: relative;  }  .track-list li {    position: relative;    padding: 24px 0 0 24px;    line-height: 18px;    border-left: 1px dashed #2d88ff;    color: #787878;  }  .track-list li.first {    padding-top: 0;  }  .track-list li .node-icon {    position: absolute;    left: -12px;    width: 24px;    height: 24px;    line-height: 24px;    border-radius: 33%;    background-color: #2d88ff;    box-shadow: 0 0 4px #2d88ff;    text-align: center;    font-size: 12px;    color: #fff;    z-index: 1;  }  .track-list li .txt {    font-size: 16px;  }  ```    页面样式展示    <img :src=\'$withBase("/images/20190304timeline.png")\' alt=\'时间轴\'>    以上    浏览地址： <https://asazws.github.io/Merchant-activity/business-agent.html>'},{title:"2019-03-03【js手动实现一个new】",path:"/posts/2019-03-03%E3%80%90js%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAnew%E3%80%91.html",strippedContent:" ### js手动实现一个new    要想手动实现一个new，就要知道new究竟干了什么        我们先new一下    ```js  var obj = new Test();  ```    其实上面这个new就干了三件事：    ```js  var obj = {};  // 我们创建了一个空对象obj  obj.__proto__ = Test.prototype;  // 我们将这个空对象的__proto__成员指向了Test函数对象prototype成员对象  Test.call(obj);  // 我们将Test函数对象的this指针替换成obj，然后调用Test函数，于是我们就给obj对象赋值了一个id成员变量，这个成员变量的值是\"test\"，关于函数call的用法  ```    看了new干了什么后，我们就来着手实现功能了    ```js  function create(Con, ...args) {      let obj = {};      Object.setPrototypeOf(obj, Con.prototype);      let result = Con.apply(obj, args);      return result instanceof Object ? result : obj;  }  ```    以上就是我们的完整代码，我们通过以下几个步骤实现的：    - 首先函数接受不定量的参数，第一个参数为构造函数，接下来的参数被构造函数使用    - 然后内部创建一个空对象 obj    - 因为 obj 对象需要访问到构造函数原型链上的属性，所以我们通过 setPrototypeOf 将两者联系起来。这段代码等同于 obj.__proto__ = Con.prototype    - 将 obj 绑定到构造函数上，并且传入剩余的参数    - 判断构造函数返回值是否为对象，如果为对象就使用构造函数返回的值，否则使用 obj，这样就实现了忽略构造函数返回的原始值      接下来我们来使用下该函数，看看行为是否和 new 操作符一致    ```js  function Test(name, age) {      this.name = name;      this.age = age;  }  Test.prototype.sayName = function () {      console.log(this.name);  }  const a = create(Test, 'asa', 24);  console.log(a.name);  // 'asa'  console.log(a.age);  // 24  a.sayName()  // 'asa'  ```    以上    参考链接： <https://mp.weixin.qq.com/s/TIJP7pNk5_MeQzXaa1RqpQ>"},{title:"2019-03-02【vscde-git报错】",path:"/posts/2019-03-02%E3%80%90vscode-gitbaoc%E3%80%91.html",strippedContent:' #### 更新版本-1.19.3  报如下错误  ![](https://user-gold-cdn.xitu.io/2018/2/1/1614f0384a6c3daa?w=997&h=74&f=png&s=10671)  原因可能是 git.path 设置成了null, 按照如下更改后重启Vs就好了  ![](https://user-gold-cdn.xitu.io/2018/2/1/1614f082d62a9ac5?w=1304&h=284&f=png&s=55850)  <h3 style="color: #f34e33;">注意：</h3>  不要使用这样的路径风格，例如&nbsp;&nbsp;D:\\ruanjian\\git\\Git\\bin\\bash.exe <br/>  一定要使用这样的路径风格，例如&nbsp;&nbsp;D:/ruanjian/git/Git/bin/bash.exe'},{title:"2019-03-01【javascript中的类】",path:"/posts/2019-03-01%E3%80%90javascript%E4%B8%AD%E7%9A%84%E7%B1%BB%E3%80%91.html",strippedContent:" ### ES5中的类  在ES5中，我们把 new 理解成 javascript 面向对象的一部分，下面我们就来看一下 new 操作具体为我们做了那些事情。       new运算符接收一个构造器和一组调用参数，实际上做了几件事：      1.以构造器的prototype属性（注意与私有字段[[prototype]]的区分）为原型，创建新对象；      2.将this和调用参数传给构造器，执行；      3.如果构造器返回的是对象，则返回，否则返回第一步创建的对象。  new这样的行为，试图让函数对象在语法上跟类变得相似，但是，它客观上提供了两种方式，一是在构造器中添加属性，二是在构造器的prototype属性上添加属性。      下面代码展示了用构造器模拟类的两种方法：  ```js  function c1() {  this.p1 = 1;  this.p2 = function (){      console.log(this.p1);  }  }  var o1 = new c1;  o1.p2();      function c2(){  }  c2.prototype.p1 = 1;  c2.prototype.p2 = function (){  console.log(this.p1);  }  var o2 = new c2;  o2.p2();  ```  第一种方法是直接在构造器中修改this，给this添加属性。    第二种方法是修改构造器的prototype属性指向的对象，它是从这个构造器构造出来的所有对象的原型。    ### ES6中的类    ES6中引入了classES6 中引入了 class 关键字，并且在标准中删除了所有[[class]] 相关的私有属性描述，类的概念正式从属性升级成语言的基础设施，从此，基于类的编程方式成为了 JavaScript 的官方编程范式。        我们先看下类的基本写法：    ```js  class Rectangle {    constructor(height, width) {      this.height = height;      this.width = width;    }    // Getter    get area() {      return this.calcArea();    }    // Method    calcArea() {      return this.height * this.width;    }  }    ```  在现有的类语法中，getter/setter 和 method 是兼容性最好的。    我们通过 get/set 关键字来创建 getter，通过括号和大括号来创建方法，数据型成员最好写在构造器里面。    类的写法实际上也是由原型运行时来承载的，逻辑上 JavaScript 认为每个类是有共同原型的一组对象，类中定义的方法和属性则会被写在原型对象之上。"},{title:"2019-2-28【mac下node和npm删除及重新安装】",path:"/posts/2019-2-28%E3%80%90mac%E4%B8%8Bnode%E5%92%8Cnpm%E5%88%A0%E9%99%A4%E5%8F%8A%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85%E3%80%91.html",strippedContent:" mac由于平时不太了解，导致后面npm出错，现在想删除重装  ### 删除  #### 如果是用 brew 安装的node，用下面的命令卸载      brew uninstall node  #### 进入 /usr/local/bin 删除 node 执行文件      cd /usr/local/bin        sudo rm -rf /usr/local/bin/npm        sudo rm -rf /usr/local/bin/node  #### 仔细检查，全局安装的npm包一般会在这个目录下创建软连接，发现就删除      ls  #### 其他清理工作      sudo rm -rf /usr/local/share/man/man1/node.1        sudo rm -rf /usr/local/lib/dtrace/node.d        sudo rm -rf ~/.npm  ### 安装  #### 安装cnpm      sudo npm install -g cnpm –registry=https://registry.npm.taobao.org/  #### 如果报错执行如下命令      npm set registry https://registry.npm.taobao.org # 注册模块镜像        npm set disturl https://npm.taobao.org/dist # node-gyp 编译依赖的 node 源码镜像        npm cache clean # 清空缓存        sudo npm install -g cnpm –registry=https://registry.npm.taobao.org/ #重新安装  #### npm升级到最新版本      npm install npm@latest -g"},{title:"2019-2-27【SASS安装与学习】",path:"/posts/2019-2-27%E3%80%90SASS%E5%AE%89%E8%A3%85%E4%B8%8E%E5%AD%A6%E4%B9%A0%E3%80%91.html",strippedContent:" SASS具有两种语法。新的主要语法（SASS 3）称作SCSS (Sassy CSS)，同时支持CSS3的语法。也就是说只要CSS3支持的在SCSS中也被支持。SCSS文件扩展名为'.scss'，这也是当下使用最多的。    ### scss预处理器的编译方法  - 由于SASS是在Ruby环境下运行，所以大家首先需要在自己的工作电脑上安装Ruby。  -  检测Ruby是否已安装：  ```  $ ruby -v  ```  #### SASS的安装  ```  $ gem install sass   ```  - 安装完成后，可以通过下面的命令查看SASS是否安装成功：  ```  $ gem list  ```  - 安装完成后，可以通过下面的命令查看SASS是否安装成功：  ```  $ sass -v  ```  #### Beat版本安装  - 对于SASS的发烧友来说，一个稳定版本并不能满足需求，他需要一些别的东西，也就是说他想获取SASS的一些最新变化和最新功能。那么这个时候你就可以安装一个Beat版本的SASS，他会自己会自动创建每次更改的主分支：  ```  $ gem install sass --pre  ```  #### 创建你的第一个SASS项目  - 为了让项目规化的更完美一些，我把.scss的SASS文件都放在sass目录中，而需要转译出来的.css文件都将放在css目录中。因此，我们还需要在mySass项目中创建sass和css两个文件夹,在cass里面写好你的scss项目(注意：头部写好@charset \"utf-8\";)：  ```  $ cd mySass   $ mkdir sass   $ mkdir css  ```  #### SASS文件转译  - 转译.scss文件，我们主要使用的是sass命令。其操作非常简单，首先进入到对应的项目中:  ```  $ sass sass/index.scss css/index.css  ```  - 使用sass转译.scss文件，有一个不足之处，就是我们修改了.scss文件，不会自动转译。那么我们只需要在sass命令的基础上添加一个参数--watch就可以自动转译。  - 特别强调：如果使用sass --watch转译.scss样式，首先需要安装rb-fsevent  ```  $ sass --watch test.scss:test.css  ```  - 为了能让sass --watch命令运行正常，也就是时时能监控，只需要安装rb-fsevent即可:  - 这个时候再执行：  ```  $ sass --watch sass/style.scss  ```  - 他的优点是可以时间监控转译.scss文件，他不足的一处是转译出来的不在css目录下，只能在自己的文件夹下，到时候麻烦自己在复制一下  - 在SASS中，可以直接将整个目录中的所有.scss文件转译成所有的.css文件，并放到另一个CSS目录中  ```  $ sass --watch sass/:css/  ```  #### CSS转译成SASS  ```  $ sass-convert css/style.css style.scss  ```  原文出处： <http://www.w3cplus.com/preprocessor/sass-compile.html>"},{title:"2019-2-26【2019年应该要做的事情】",path:"/posts/2019-2-26%E3%80%902019%E5%B9%B4%E5%BA%94%E8%AF%A5%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85%E3%80%91.html",strippedContent:" #### 一、每天上班前多想想当天的工作如何开展。  #### 二、多看书，多看书，多看书。    > 1) 书架上的书先撸完  #### 三、好好维护vuepress技术博客，每天7点早起（周末可睡到8点），一天一篇技术点文章，每周写一篇总结，希望坚持下去（喝酒当天另算）！  #### 四、前端持续学习  >1) css技术样式，重点学习css3、sass。    >2) js不间断学习，重点学习vue、es6、node。    >3) 掌握一门后端语言python。"}]}}]);