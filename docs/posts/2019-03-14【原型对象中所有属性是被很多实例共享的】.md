---
title: 2019-03-14【原型对象是被很多实例共享的】
date: 2019-03-14 10:54:24
tags: [javascript》]
categories: [javascript]
---

### 原型对象的问题  

原型模式也不是没有缺点。首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。原型模式的最大问题是由其共享的本质所导致的。  

原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性到也说的过去，通过在实例上添加了一个同名属性，可以隐藏原型中的对应属性。然而，对于包含引用类型的属性来说，问题就比较突出了。

我们来看一个例子。

```js
function Person(){

}
Person.prototype = {
    constructor: Person,
    name: 'Nicholas',
    age: 29,
    job: 'Software Engineer',
    friends: ["Shelby", "Court"],
    sayName: function(){
        console.log(this.name);
    }
};
var person1 = new Person();
var person2 = new Person();
person1.friends.push("Van");
console.log(person1.friends);  // "Shelby,Court,Van"
console.log(person2.friends);  // "Shelby,Court,Van"
console.log(person1.friends === person2.friends); // true
console.log(person1.name === person2.name); // true
```

friends数组存在与Person.prototype而非person1中，所以上面person2.friends(与person1.friends指向同一个数组)反应出来，而这个问题正是我们很少看到有人单独使用原型模式的原因所在。

以上